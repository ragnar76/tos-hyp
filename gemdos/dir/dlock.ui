!iflang [english]


!begin_node Dlock
(!begin_liste) [Availability]
!item [Name:]
ØDlockÆ - Lock a (!nolink [BIOS]) device or releases it again.

!item [Opcode:]
309

!item [Syntax:]
int32_t Dlock ( int16_t mode, int16_t drv );

!item [Description:]
The function Dlock permits the locking of the (!nolink [BIOS]) device
(!I)drv(!i), or releasing it again. On a locked drive no (!nolink [GEMDOS])
file operations are permitted; Rwabs is only allowed for the locking
process.

The purpose of the function is to allow low-level programs (such as those
for formatting) to perform (X)(!nolink [BIOS]) functions, while the device
remains locked for normal file accesses.

!begin_table [r l]
Bit 0 of (!I)mode(!i) = 1: !! Lock device
= 0: !! Release device
!end_table

If a process is terminated that still holds a lock on a device, then this
lock will be lifted.

Bit 1 of (!I)mode(!i) indicates which return values are desired. If this bit
is set, and the corresponding device is already locked by another process
(or if another process has opened files on this device), then this process'
ID will be returned. This permits more meaningful error-messages to the
user, as one can now disclose which process is using the device if the
locking should go wrong.

All other bits of (!I)mode(!i) are reserved and must be set to 0.

Locking of a device with immediately following release of the same is very
similar to a media change. One should merely note that it is not possible to
lock if files are still open on the specified device.

(!B)Note for MagiC:(!b) Before locking of the drive, provided a file-system
exists for the drive, the caches will be written back via the vector
xfs_sync. Then the kernel inquires via xfs_drv_close whether the drive may
be locked. If so, the XFS releases its structures and then signals the
kernel that it too can release its structures for the drive, and perform the
lock.

!item [(!nolink [Return]) value:]
The function can return the following values:

!begin_xlist !short [ELOCKED :]
!item [E_OK :]
No error has arisen
!item [EACCDN :]
Device could not be locked, as open files or directories exist on it
!item [EDRIVE :]
(!I)drv(!i) is not a valid (!nolink [BIOS]) device
!item [ELOCKED :]
Device is already locked by another process
!item [ENSLOCK :]
Device has been released already
!end_xlist

!item [Availability:]
Available when a 'MiNT' cookie with a version of at least 0.93 exists, and
MagiC as of Version 3.0.

!item [Group:]
Directory functions

!item [See also:]
(!link [Binding][Bindings for Dlock]) ~ Fxattr ~
(!link [XFS-concept in MagiC][MagiC's XFS-concept])
(!ende_liste)


!begin_node Bindings for Dlock
!ignore_index
(!begin_liste) [Assembler:]
!item [C:]
int32_t Dlock ( int16_t mode, int16_t drv );

!item [Assembler:]
!begin_verbatim
move.w    drv,-(sp)    ; Offset 4
move.w    mode,-(sp)   ; Offset 2
move.w    #309,-(sp)   ; Offset 0
trap      #1           ; GEMDOS
addq.l    #6,sp        ; Correct stack
!end_verbatim
(!ende_liste)
!end_node
!end_node


!else


!begin_node Dlock
(!begin_liste) [Beschreibung]
!item [Name:]
ØDlockÆ - sperrt ein BIOS GerÑt bzw. gibt es wieder frei.

!item [Gemdosnummer:]
309

!item [Deklaration:]
int32_t Dlock ( int16_t mode, int16_t drv );

!item [Beschreibung:]
Die Funktion erlaubt es, das BIOS-GerÑt (!I)drv(!i) zu sperren, bzw. wieder
freizugeben. Auf einem gelockten Laufwerk sind keine GEMDOS File-Operationen
zugelassen; Rwabs ist nur fÅr den sperrenden Prozess erlaubt.

Der Sinn und Zweck der Funktion besteht darin, daû Low-Level Programme (etwa
zum Formatieren) (X)(!nolink [BIOS]) Funktionen ausfÅhren kînnen, wÑhrend das GerÑt fÅr
normale Dateizugriffe gesperrt bleibt.

!begin_table [r l]
Bit 0 von mode = 1: !! GerÑt sperren
= 0: !! GerÑt freigeben
!end_table

Wird ein Prozeû beendet der noch eine Sperre auf einem GerÑt hÑlt, so wird
diese Sperre aufgehoben.

Bit 1 von (!I)mode(!i) zeigt an, welche RÅckgabewerte gewÅnscht sind. Ist
dieses Bit gesetzt, und das entsprechende GerÑt bereits von einem anderen
Prozeû gesperrt (oder hat ein anderer Prozeû Files auf diesem GerÑt
geîffnet), dann wird dessen Prozeû-ID zurÅckgeliefert. Dies erlaubt
sinnvollere Fehlermeldungen an den Benutzer, da nun mitgeteilt werden kann,
welcher Prozeû das GerÑt benutzt, wenn das Sperren fehlschlagen sollte.

Alle anderen Bits von (!I)mode(!i) sind reserviert und mÅssen auf 0 gesetzt
werden.

Ein Sperren eines GerÑtes mit unmittelbar folgendem Freigeben desselben, ist
einem Medienwechsel sehr Ñhnlich. Zu beachten ist lediglich, daû nicht
gesperrt werden kann, wenn auf dem angegebenen GerÑt noch Dateien geîffnet
sind.

(!B)Hinweis fÅr (!nolink [MagiC]):(!b) Vor Sperren des Laufwerks werden, falls ein
Dateisystem fÅr das Laufwerk existiert, die Caches Åber den Vektor xfs_sync
zurÅckgeschrieben. Dann stellt der Kernel Åber xfs_drv_close eine Anfrage,
ob das Laufwerk gesperrt werden kann. Wenn ja, gibt das XFS seine Strukturen
frei und signalisiert dann dem Kernel, daû auch er seine Strukturen fÅr das
Laufwerk freigeben und die Sperrung durchfÅhren kann.

!item [Ergebnis:]
Die Funktion kann die folgenden Werte zurÅckliefern:

!begin_xlist !short [ELOCKED :]
!item [E_OK :]
kein Fehler aufgetreten.
!item [EACCDN :]
GerÑt konnte nicht gesperrt werden, da offene Dateien bzw. Verzeichnisse
vorhanden sind.
!item [EDRIVE :]
(!I)drv(!i) ist kein gÅltiges (!nolink [BIOS])-GerÑt.
!item [ELOCKED :]
GerÑt ist bereits von einem Prozeû gesperrt.
!item [ENSLOCK :]
GerÑt ist bereits freigegeben.
!end_xlist

!item [VerfÅgbar:]
VerfÅgbar, wenn ein 'MiNT' Cookie mit einer Versionsnummer von mindestens
0.93 existiert und in MagiC ab Version 3.0.

!item [Gruppe:]
Verzeichnisfunktionen

!item [Querverweis:]
(!link [Binding][Bindings fÅr Dlock]) ~ Fxattr ~
(!link [XFS-Konzept in MagiC][Das XFS-Konzept von MagiC])
(!ende_liste)


!begin_node Bindings fÅr Dlock
!ignore_index
(!begin_liste) [Assembler:]
!item [C:]
int32_t Dlock ( int16_t mode, int16_t drv );

!item [Assembler:]
!begin_verbatim
move.w    drv,-(sp)    ; Offset 4
move.w    mode,-(sp)   ; Offset 2
move.w    #309,-(sp)   ; Offset 0
trap      #1           ; GEMDOS aufrufen
addq.l    #6,sp        ; Stack korrigieren
!end_verbatim
(!ende_liste)
!end_node
!end_node


!endif
